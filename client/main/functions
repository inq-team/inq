#!/bin/sh
#
# Functions defined in this file are used by many rc scripts.
# 
# Author:	Miquel van Smoorenburg, <miquels@drinkel.nl.mugnet.org>
# Hacked by:	Greg Galloway and Marc Ewing
# Changed by:	Dmitry V. Levin

# Set the initial default search path for use by startup scripts.
export PATH="/sbin:/usr/sbin:/usr/local/sbin:/bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin"

ALERT_ATTENTION='65535 65535 0'
ALERT_FAILURE='65535 0 0'
ALERT_PASSED='0 65535 0'

. $SHARE_DIR/outformat

echo_success()
{
	MOVE_TO_COL
	echo -n '[ '
	SETCOLOR_SUCCESS
	echo -n 'DONE'
	SETCOLOR_NORMAL
	echo ' ]'
}

echo_failure()
{
	MOVE_TO_COL
	echo -n '['
	SETCOLOR_FAILURE
	echo -n 'FAILED'
	SETCOLOR_NORMAL
	echo ']'
}

echo_skipped()
{
	MOVE_TO_COL
	echo -n '['
	SETCOLOR_WARNING
	echo -n ' SKIP '
	SETCOLOR_NORMAL
	echo ']'
}

echo_passed()
{
	MOVE_TO_COL
	echo -n '['
	SETCOLOR_WARNING
	echo -n 'PASSED'
	SETCOLOR_NORMAL
	echo ']'
}

echo_running()
{
	MOVE_TO_COL
	echo -n '['
	SETCOLOR_WARNING
	echo -n 'CALLED'
	SETCOLOR_NORMAL
	echo ']'
}

# Log that something succeeded
success()
{
	echo -n $1
	echo_success
}

# Log that something failed
failure()
{
	echo -n $1
	echo_failure
}

# Log that something is skipped, because no support for it found
skipped()
{
	echo -n $1
	echo_skipped
}

test_progress()
{
	COMPLETE=$1
	TOTAL=$2

	echo -en "\r"
	echo -n "Test $TEST_NAME "

	echo -en $COMPLETE/$TOTAL"\t"

	#Show percents
	if [ "$TOTAL" -gt 40 ] ; then
		echo -n "("$(( 100 * $COMPLETE / $TOTAL ))%")"
	else
		echo -n "["
		for i in `seq 1 $COMPLETE` ; do echo -n "#" ; done
		for i in `seq $(($COMPLETE + 1)) $TOTAL` ; do echo -n "." ; done
		echo -n "]"
	fi

	test_stage_progress $COMPLETE $TOTAL
}

# Issues a managed test run; should be called by a planner
#
# Input:
# $1 - script in test directory to run
# TEST_NAME - unique identifier of test stage in testing (for database)
# + variables to pass to the test
run_test()
{
	# Mark test as started
	echo -n "Test $TEST_NAME"
	echo_running
	test_stage_advance "$TEST_NAME" start

	MSG_DIR=`mktemp -d`
	# Run test, collect status + comment
	export PLANNER=1
	(if "$SHARE_DIR/test/$1" 4>$MSG_DIR/comment 2>&1; then
		echo -n "Test $TEST_NAME"
		echo_success
		test_stage_advance "$TEST_NAME" finish "`cat $MSG_DIR/comment`"
	else
		echo -n "Test $TEST_NAME"
		echo_failure
		test_stage_advance "$TEST_NAME" fail "`cat $MSG_DIR/comment`"
		echo
		echo "Fatal failure: testing stops"
		echo "Reason: $COMMENT"
		exit 1
	fi) | tee /dev/inqlog
}

refresh_console()
{
	chvt 4
	sleep 1
	chvt 1
	test_set_status	
}

watchdog_start()
{
	echo -n 'Starting watchdog'
	watchdog &
	echo $! >~/watchdog.pid
	echo_success
}

watchdog_stop()
{
	echo -n 'Stopping watchdog'
	if [ -r ~/watchdog.pid ]; then
		kill `cat ~/watchdog.pid` ||
		rm -f ~/watchdog.pid
		echo_success
	else
		echo_skipped
	fi
}

# start_background(PIDFILE, CPULIST, CMDLINE)
# Starts a process CMDLINE in background, setting CPU affinity to
# CPU_LIST (if not empty). Saves PID of the program in PIDFILE.
start_background()
{
	local PIDFILE=$1
	shift
	local CPULIST=$1
	shift
	if [ -n "$CPULIST" ]; then
		taskset	-c "$CPULIST" $@ &
		echo $! >$PIDFILE
	else
		$@ &
		echo $! >$PIDFILE
	fi
}

stop_background()
{
	kill `cat "$1"`
	rm -f "$1"
}

print_green_message()
{
	echo ""
	SETCOLOR_SUCCESS
	echo "$1"
	SETCOLOR_NORMAL
	echo ""
}

print_red_message()
{
	echo ""
	SETCOLOR_FAILURE
	echo "$1"
	SETCOLOR_NORMAL
	echo ""
}

IP_SUITE='/sbin/ip'

dev_for_route_to_server()
{
	dev=`$IP_SUITE -o -4 route get $SERVER | grep -o 'dev [^ ]*'`
	echo ${dev#'dev '}
}

subnet_for_dev()
{
	local dev=$1
	local ip=
	local mask=
	local addr='\([0-9]\+\)'
	addr=$addr'\.'$addr'\.'$addr'\.'$addr
	local pattern='ip=$(( ((\1 << 24) | (\2 << 16) | (\3 << 8) | (\4)) \& (((1 << (32 - \5)) - 1) ^ 0xffffffff) ));'
	pattern=$pattern'mask=\5;'
	pattern='s/^.*inet '$addr'\/\([0-9]\+\).*$/'$pattern'/'
	eval `$IP_SUITE -o -4 address show $dev | sed "$pattern" `
	echo "$(( ip >> 24 )).$(( (ip >> 16) & 255 )).$(( (ip >> 8) & 255 )).$(( ip & 255 ))/$mask"
}

get_harddrives_list()
{
	for i in `hal-find-by-property --key=storage.drive_type --string disk`
	do
		hal-device $i | grep block.device | \
		awk '{print $3}' | sed "s/'//g"
	done
}

get_odds_list()
{
	for i in `hal-find-by-capability --capability storage.cdrom`; do
		hal-device $i | grep access_control.file | \
		awk '{print $3}' | sed "s/'//g"
	done
}
